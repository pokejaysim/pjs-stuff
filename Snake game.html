<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta http-equiv="Content-Style-Type" content="text/css">
  <title></title>
  <meta name="Generator" content="Cocoa HTML Writer">
  <meta name="CocoaVersion" content="2575.4">
  <style type="text/css">
    p.p1 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica}
    p.p2 {margin: 0.0px 0.0px 0.0px 0.0px; font: 12.0px Helvetica; min-height: 14.0px}
  </style>
</head>
<body>
<p class="p1">// Constants</p>
<p class="p1">const GRID_SIZE = 20;</p>
<p class="p1">const GRID_WIDTH = 30;</p>
<p class="p1">const GRID_HEIGHT = 30;</p>
<p class="p1">const FRAME_RATE = 15;</p>
<p class="p1">const SNAKE_COLORS = [</p>
<p class="p1"><span class="Apple-converted-space">  </span>[255, 50, 50], <span class="Apple-converted-space">  </span>// Red</p>
<p class="p1"><span class="Apple-converted-space">  </span>[50, 255, 50], <span class="Apple-converted-space">  </span>// Green</p>
<p class="p1"><span class="Apple-converted-space">  </span>[50, 50, 255], <span class="Apple-converted-space">  </span>// Blue</p>
<p class="p1"><span class="Apple-converted-space">  </span>[255, 255, 50],<span class="Apple-converted-space">  </span>// Yellow</p>
<p class="p1"><span class="Apple-converted-space">  </span>[255, 50, 255] <span class="Apple-converted-space">  </span>// Purple</p>
<p class="p1">];</p>
<p class="p1">const MAX_FOOD = 3;</p>
<p class="p2"><br></p>
<p class="p1">// Game variables</p>
<p class="p1">let snakes = [];</p>
<p class="p1">let foods = [];</p>
<p class="p1">let gameOver = false;</p>
<p class="p1">let scores = [0, 0, 0, 0, 0];</p>
<p class="p1">let gameTime = 0;</p>
<p class="p1">let maxGameTime = 60 * FRAME_RATE; // 60 seconds</p>
<p class="p2"><br></p>
<p class="p1">function setup() {</p>
<p class="p1"><span class="Apple-converted-space">  </span>createCanvas(GRID_WIDTH * GRID_SIZE, GRID_HEIGHT * GRID_SIZE);</p>
<p class="p1"><span class="Apple-converted-space">  </span>frameRate(FRAME_RATE);</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Initialize snakes</p>
<p class="p1"><span class="Apple-converted-space">  </span>for (let i = 0; i &lt; 5; i++) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>// Position snakes in different corners and center</p>
<p class="p1"><span class="Apple-converted-space">    </span>let startPos;</p>
<p class="p1"><span class="Apple-converted-space">    </span>switch(i) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>case 0: startPos = createVector(5, 5); break; // Top left</p>
<p class="p1"><span class="Apple-converted-space">      </span>case 1: startPos = createVector(GRID_WIDTH - 5, 5); break; // Top right</p>
<p class="p1"><span class="Apple-converted-space">      </span>case 2: startPos = createVector(5, GRID_HEIGHT - 5); break; // Bottom left</p>
<p class="p1"><span class="Apple-converted-space">      </span>case 3: startPos = createVector(GRID_WIDTH - 5, GRID_HEIGHT - 5); break; // Bottom right</p>
<p class="p1"><span class="Apple-converted-space">      </span>case 4: startPos = createVector(GRID_WIDTH/2, GRID_HEIGHT/2); break; // Center</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>snakes.push(new Snake(i, startPos, SNAKE_COLORS[i]));</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Add initial food</p>
<p class="p1"><span class="Apple-converted-space">  </span>for (let i = 0; i &lt; MAX_FOOD; i++) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>addFood();</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">function draw() {</p>
<p class="p1"><span class="Apple-converted-space">  </span>background(20);</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Draw grid</p>
<p class="p1"><span class="Apple-converted-space">  </span>stroke(40);</p>
<p class="p1"><span class="Apple-converted-space">  </span>strokeWeight(1);</p>
<p class="p1"><span class="Apple-converted-space">  </span>for (let i = 0; i &lt; GRID_WIDTH; i++) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>line(i * GRID_SIZE, 0, i * GRID_SIZE, height);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>for (let i = 0; i &lt; GRID_HEIGHT; i++) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>line(0, i * GRID_SIZE, width, i * GRID_SIZE);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Update game time</p>
<p class="p1"><span class="Apple-converted-space">  </span>if (!gameOver) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>gameTime++;</p>
<p class="p1"><span class="Apple-converted-space">    </span>if (gameTime &gt;= maxGameTime) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>gameOver = true;</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Draw and update food</p>
<p class="p1"><span class="Apple-converted-space">  </span>for (let food of foods) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>food.draw();</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Draw and update snakes</p>
<p class="p1"><span class="Apple-converted-space">  </span>if (!gameOver) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>for (let snake of snakes) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>if (snake.alive) {</p>
<p class="p1"><span class="Apple-converted-space">        </span>snake.think();</p>
<p class="p1"><span class="Apple-converted-space">        </span>snake.update();</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">      </span>snake.draw();</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Add food if needed</p>
<p class="p1"><span class="Apple-converted-space">  </span>while (foods.length &lt; MAX_FOOD) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>addFood();</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Draw UI</p>
<p class="p1"><span class="Apple-converted-space">  </span>drawUI();</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Check if all snakes are dead</p>
<p class="p1"><span class="Apple-converted-space">  </span>if (!gameOver &amp;&amp; snakes.every(s =&gt; !s.alive)) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>gameOver = true;</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">function drawUI() {</p>
<p class="p1"><span class="Apple-converted-space">  </span>// Draw score and timer</p>
<p class="p1"><span class="Apple-converted-space">  </span>fill(255);</p>
<p class="p1"><span class="Apple-converted-space">  </span>noStroke();</p>
<p class="p1"><span class="Apple-converted-space">  </span>textSize(16);</p>
<p class="p1"><span class="Apple-converted-space">  </span>textAlign(LEFT, TOP);</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Timer</p>
<p class="p1"><span class="Apple-converted-space">  </span>let timeLeft = floor((maxGameTime - gameTime) / FRAME_RATE);</p>
<p class="p1"><span class="Apple-converted-space">  </span>let timeStr = "Time: " + timeLeft + "s";</p>
<p class="p1"><span class="Apple-converted-space">  </span>text(timeStr, 10, 10);</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Scores</p>
<p class="p1"><span class="Apple-converted-space">  </span>for (let i = 0; i &lt; 5; i++) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>fill(SNAKE_COLORS[i]);</p>
<p class="p1"><span class="Apple-converted-space">    </span>let snakeStatus = snakes[i].alive ? "🐍" : "💀";</p>
<p class="p1"><span class="Apple-converted-space">    </span>text(`Snake ${i+1}: ${scores[i]} ${snakeStatus}`, 10, 40 + i * 25);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Game over message</p>
<p class="p1"><span class="Apple-converted-space">  </span>if (gameOver) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>textAlign(CENTER, CENTER);</p>
<p class="p1"><span class="Apple-converted-space">    </span>textSize(36);</p>
<p class="p1"><span class="Apple-converted-space">    </span>fill(255);</p>
<p class="p1"><span class="Apple-converted-space">    </span>text("GAME OVER", width/2, height/2 - 40);</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>textSize(24);</p>
<p class="p1"><span class="Apple-converted-space">    </span>let winner = scores.indexOf(Math.max(...scores));</p>
<p class="p1"><span class="Apple-converted-space">    </span>fill(SNAKE_COLORS[winner]);</p>
<p class="p1"><span class="Apple-converted-space">    </span>text(`Snake ${winner+1} wins with ${scores[winner]} points!`, width/2, height/2 + 10);</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>textSize(16);</p>
<p class="p1"><span class="Apple-converted-space">    </span>fill(200);</p>
<p class="p1"><span class="Apple-converted-space">    </span>text("Click to restart", width/2, height/2 + 50);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">function mousePressed() {</p>
<p class="p1"><span class="Apple-converted-space">  </span>if (gameOver) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>// Reset game</p>
<p class="p1"><span class="Apple-converted-space">    </span>snakes = [];</p>
<p class="p1"><span class="Apple-converted-space">    </span>foods = [];</p>
<p class="p1"><span class="Apple-converted-space">    </span>scores = [0, 0, 0, 0, 0];</p>
<p class="p1"><span class="Apple-converted-space">    </span>gameTime = 0;</p>
<p class="p1"><span class="Apple-converted-space">    </span>gameOver = false;</p>
<p class="p1"><span class="Apple-converted-space">    </span>setup();</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">function addFood() {</p>
<p class="p1"><span class="Apple-converted-space">  </span>let pos;</p>
<p class="p1"><span class="Apple-converted-space">  </span>let overlapping;</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>// Find a position that doesn't overlap with snakes or other food</p>
<p class="p1"><span class="Apple-converted-space">  </span>do {</p>
<p class="p1"><span class="Apple-converted-space">    </span>overlapping = false;</p>
<p class="p1"><span class="Apple-converted-space">    </span>pos = createVector(</p>
<p class="p1"><span class="Apple-converted-space">      </span>floor(random(1, GRID_WIDTH - 1)),</p>
<p class="p1"><span class="Apple-converted-space">      </span>floor(random(1, GRID_HEIGHT - 1))</p>
<p class="p1"><span class="Apple-converted-space">    </span>);</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>// Check overlap with food</p>
<p class="p1"><span class="Apple-converted-space">    </span>for (let food of foods) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>if (food.pos.x === pos.x &amp;&amp; food.pos.y === pos.y) {</p>
<p class="p1"><span class="Apple-converted-space">        </span>overlapping = true;</p>
<p class="p1"><span class="Apple-converted-space">        </span>break;</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>// Check overlap with snakes</p>
<p class="p1"><span class="Apple-converted-space">    </span>if (!overlapping) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>for (let snake of snakes) {</p>
<p class="p1"><span class="Apple-converted-space">        </span>for (let segment of snake.body) {</p>
<p class="p1"><span class="Apple-converted-space">          </span>if (segment.x === pos.x &amp;&amp; segment.y === pos.y) {</p>
<p class="p1"><span class="Apple-converted-space">            </span>overlapping = true;</p>
<p class="p1"><span class="Apple-converted-space">            </span>break;</p>
<p class="p1"><span class="Apple-converted-space">          </span>}</p>
<p class="p1"><span class="Apple-converted-space">        </span>}</p>
<p class="p1"><span class="Apple-converted-space">        </span>if (overlapping) break;</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>} while (overlapping);</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>foods.push(new Food(pos));</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">class Snake {</p>
<p class="p1"><span class="Apple-converted-space">  </span>constructor(id, pos, color) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.id = id;</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.color = color;</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.body = [pos.copy()];</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.velocity = createVector(1, 0); // Start moving right</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.alive = true;</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.growCount = 2; // Start with length 3</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.lastDirection = 'right';</p>
<p class="p1"><span class="Apple-converted-space">    </span>// Add slightly different personalities to each snake</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.personality = {</p>
<p class="p1"><span class="Apple-converted-space">      </span>aggressiveness: random(0.2, 0.8),</p>
<p class="p1"><span class="Apple-converted-space">      </span>carefulness: random(0.3, 0.9),</p>
<p class="p1"><span class="Apple-converted-space">      </span>foodPriority: random(0.6, 1.0),</p>
<p class="p1"><span class="Apple-converted-space">      </span>// The snake with id 0 is slightly smarter</p>
<p class="p1"><span class="Apple-converted-space">      </span>intelligence: id === 0 ? random(0.7, 0.9) : random(0.5, 0.8)</p>
<p class="p1"><span class="Apple-converted-space">    </span>};</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>think() {</p>
<p class="p1"><span class="Apple-converted-space">    </span>// Find nearest food</p>
<p class="p1"><span class="Apple-converted-space">    </span>let nearestFood = null;</p>
<p class="p1"><span class="Apple-converted-space">    </span>let minDist = Infinity;</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>for (let food of foods) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>let dist = this.manhattanDistance(this.body[0], food.pos);</p>
<p class="p1"><span class="Apple-converted-space">      </span>if (dist &lt; minDist) {</p>
<p class="p1"><span class="Apple-converted-space">        </span>minDist = dist;</p>
<p class="p1"><span class="Apple-converted-space">        </span>nearestFood = food;</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>if (nearestFood) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>// Possible directions</p>
<p class="p1"><span class="Apple-converted-space">      </span>const directions = [</p>
<p class="p1"><span class="Apple-converted-space">        </span>{ dx: 1, dy: 0, name: 'right' },</p>
<p class="p1"><span class="Apple-converted-space">        </span>{ dx: -1, dy: 0, name: 'left' },</p>
<p class="p1"><span class="Apple-converted-space">        </span>{ dx: 0, dy: 1, name: 'down' },</p>
<p class="p1"><span class="Apple-converted-space">        </span>{ dx: 0, dy: -1, name: 'up' }</p>
<p class="p1"><span class="Apple-converted-space">      </span>];</p>
<p class="p2"><span class="Apple-converted-space">      </span></p>
<p class="p1"><span class="Apple-converted-space">      </span>// Filter out opposite direction to prevent immediate death</p>
<p class="p1"><span class="Apple-converted-space">      </span>const validDirections = directions.filter(dir =&gt; {</p>
<p class="p1"><span class="Apple-converted-space">        </span>if ((this.lastDirection === 'right' &amp;&amp; dir.name === 'left') ||</p>
<p class="p1"><span class="Apple-converted-space">            </span>(this.lastDirection === 'left' &amp;&amp; dir.name === 'right') ||</p>
<p class="p1"><span class="Apple-converted-space">            </span>(this.lastDirection === 'up' &amp;&amp; dir.name === 'down') ||</p>
<p class="p1"><span class="Apple-converted-space">            </span>(this.lastDirection === 'down' &amp;&amp; dir.name === 'up')) {</p>
<p class="p1"><span class="Apple-converted-space">          </span>return false;</p>
<p class="p1"><span class="Apple-converted-space">        </span>}</p>
<p class="p1"><span class="Apple-converted-space">        </span>return true;</p>
<p class="p1"><span class="Apple-converted-space">      </span>});</p>
<p class="p2"><span class="Apple-converted-space">      </span></p>
<p class="p1"><span class="Apple-converted-space">      </span>// Score each direction</p>
<p class="p1"><span class="Apple-converted-space">      </span>const scoredDirections = validDirections.map(dir =&gt; {</p>
<p class="p1"><span class="Apple-converted-space">        </span>const newHead = createVector(</p>
<p class="p1"><span class="Apple-converted-space">          </span>this.body[0].x + dir.dx,</p>
<p class="p1"><span class="Apple-converted-space">          </span>this.body[0].y + dir.dy</p>
<p class="p1"><span class="Apple-converted-space">        </span>);</p>
<p class="p2"><span class="Apple-converted-space">        </span></p>
<p class="p1"><span class="Apple-converted-space">        </span>// Check if the move would kill us</p>
<p class="p1"><span class="Apple-converted-space">        </span>if (this.wouldDie(newHead)) {</p>
<p class="p1"><span class="Apple-converted-space">          </span>return { dir, score: -1000 };</p>
<p class="p1"><span class="Apple-converted-space">        </span>}</p>
<p class="p2"><span class="Apple-converted-space">        </span></p>
<p class="p1"><span class="Apple-converted-space">        </span>// Calculate distance to food in this direction</p>
<p class="p1"><span class="Apple-converted-space">        </span>let foodScore = -this.manhattanDistance(newHead, nearestFood.pos) * this.personality.foodPriority;</p>
<p class="p2"><span class="Apple-converted-space">        </span></p>
<p class="p1"><span class="Apple-converted-space">        </span>// Calculate safety score (avoid walls and self-collision)</p>
<p class="p1"><span class="Apple-converted-space">        </span>let safetyScore = 0;</p>
<p class="p2"><span class="Apple-converted-space">        </span></p>
<p class="p1"><span class="Apple-converted-space">        </span>// Check how much space is available in this direction</p>
<p class="p1"><span class="Apple-converted-space">        </span>let spaceFactor = this.checkFreeSpace(newHead);</p>
<p class="p1"><span class="Apple-converted-space">        </span>safetyScore += spaceFactor * 10 * this.personality.carefulness;</p>
<p class="p2"><span class="Apple-converted-space">        </span></p>
<p class="p1"><span class="Apple-converted-space">        </span>// Prefer to move in the general direction of food</p>
<p class="p1"><span class="Apple-converted-space">        </span>let directionScore = 0;</p>
<p class="p1"><span class="Apple-converted-space">        </span>if ((nearestFood.pos.x &gt; this.body[0].x &amp;&amp; dir.name === 'right') ||</p>
<p class="p1"><span class="Apple-converted-space">            </span>(nearestFood.pos.x &lt; this.body[0].x &amp;&amp; dir.name === 'left') ||</p>
<p class="p1"><span class="Apple-converted-space">            </span>(nearestFood.pos.y &gt; this.body[0].y &amp;&amp; dir.name === 'down') ||</p>
<p class="p1"><span class="Apple-converted-space">            </span>(nearestFood.pos.y &lt; this.body[0].y &amp;&amp; dir.name === 'up')) {</p>
<p class="p1"><span class="Apple-converted-space">          </span>directionScore += 20 * this.personality.intelligence;</p>
<p class="p1"><span class="Apple-converted-space">        </span>}</p>
<p class="p2"><span class="Apple-converted-space">        </span></p>
<p class="p1"><span class="Apple-converted-space">        </span>// Calculate final score with some randomness</p>
<p class="p1"><span class="Apple-converted-space">        </span>let finalScore = foodScore + safetyScore + directionScore + random(-10, 10);</p>
<p class="p2"><span class="Apple-converted-space">        </span></p>
<p class="p1"><span class="Apple-converted-space">        </span>return { dir, score: finalScore };</p>
<p class="p1"><span class="Apple-converted-space">      </span>});</p>
<p class="p2"><span class="Apple-converted-space">      </span></p>
<p class="p1"><span class="Apple-converted-space">      </span>// Sort by score and filter out deadly moves</p>
<p class="p1"><span class="Apple-converted-space">      </span>const safeMoves = scoredDirections.filter(item =&gt; item.score &gt; -999);</p>
<p class="p2"><span class="Apple-converted-space">      </span></p>
<p class="p1"><span class="Apple-converted-space">      </span>// Choose the best direction, or a random one if no safe moves</p>
<p class="p1"><span class="Apple-converted-space">      </span>if (safeMoves.length &gt; 0) {</p>
<p class="p1"><span class="Apple-converted-space">        </span>safeMoves.sort((a, b) =&gt; b.score - a.score);</p>
<p class="p1"><span class="Apple-converted-space">        </span>this.velocity.x = safeMoves[0].dir.dx;</p>
<p class="p1"><span class="Apple-converted-space">        </span>this.velocity.y = safeMoves[0].dir.dy;</p>
<p class="p1"><span class="Apple-converted-space">        </span>this.lastDirection = safeMoves[0].dir.name;</p>
<p class="p1"><span class="Apple-converted-space">      </span>} else {</p>
<p class="p1"><span class="Apple-converted-space">        </span>// No safe moves, just pick a valid one and hope for the best</p>
<p class="p1"><span class="Apple-converted-space">        </span>const randomDir = validDirections[floor(random(validDirections.length))];</p>
<p class="p1"><span class="Apple-converted-space">        </span>this.velocity.x = randomDir.dx;</p>
<p class="p1"><span class="Apple-converted-space">        </span>this.velocity.y = randomDir.dy;</p>
<p class="p1"><span class="Apple-converted-space">        </span>this.lastDirection = randomDir.name;</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>checkFreeSpace(pos) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>// Simple check for immediate surroundings</p>
<p class="p1"><span class="Apple-converted-space">    </span>let freeSpaces = 0;</p>
<p class="p1"><span class="Apple-converted-space">    </span>const directions = [</p>
<p class="p1"><span class="Apple-converted-space">      </span>{ x: 1, y: 0 },</p>
<p class="p1"><span class="Apple-converted-space">      </span>{ x: -1, y: 0 },</p>
<p class="p1"><span class="Apple-converted-space">      </span>{ x: 0, y: 1 },</p>
<p class="p1"><span class="Apple-converted-space">      </span>{ x: 0, y: -1 }</p>
<p class="p1"><span class="Apple-converted-space">    </span>];</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>for (let dir of directions) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>const checkPos = createVector(pos.x + dir.x, pos.y + dir.y);</p>
<p class="p1"><span class="Apple-converted-space">      </span>if (!this.wouldDie(checkPos)) {</p>
<p class="p1"><span class="Apple-converted-space">        </span>freeSpaces++;</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>return freeSpaces;</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>manhattanDistance(pos1, pos2) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>return abs(pos1.x - pos2.x) + abs(pos1.y - pos2.y);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>wouldDie(newHead) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>// Check wall collision</p>
<p class="p1"><span class="Apple-converted-space">    </span>if (newHead.x &lt; 0 || newHead.x &gt;= GRID_WIDTH ||<span class="Apple-converted-space"> </span></p>
<p class="p1"><span class="Apple-converted-space">        </span>newHead.y &lt; 0 || newHead.y &gt;= GRID_HEIGHT) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>return true;</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>// Check self collision</p>
<p class="p1"><span class="Apple-converted-space">    </span>for (let i = 0; i &lt; this.body.length - 1; i++) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>if (this.body[i].x === newHead.x &amp;&amp; this.body[i].y === newHead.y) {</p>
<p class="p1"><span class="Apple-converted-space">        </span>return true;</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>// Check other snake collision</p>
<p class="p1"><span class="Apple-converted-space">    </span>for (let snake of snakes) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>if (snake !== this &amp;&amp; snake.alive) {</p>
<p class="p1"><span class="Apple-converted-space">        </span>for (let segment of snake.body) {</p>
<p class="p1"><span class="Apple-converted-space">          </span>if (segment.x === newHead.x &amp;&amp; segment.y === newHead.y) {</p>
<p class="p1"><span class="Apple-converted-space">            </span>return true;</p>
<p class="p1"><span class="Apple-converted-space">          </span>}</p>
<p class="p1"><span class="Apple-converted-space">        </span>}</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>return false;</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>update() {</p>
<p class="p1"><span class="Apple-converted-space">    </span>// Move head</p>
<p class="p1"><span class="Apple-converted-space">    </span>const newHead = createVector(</p>
<p class="p1"><span class="Apple-converted-space">      </span>this.body[0].x + this.velocity.x,</p>
<p class="p1"><span class="Apple-converted-space">      </span>this.body[0].y + this.velocity.y</p>
<p class="p1"><span class="Apple-converted-space">    </span>);</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>// Check if we died</p>
<p class="p1"><span class="Apple-converted-space">    </span>if (this.wouldDie(newHead)) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>this.alive = false;</p>
<p class="p1"><span class="Apple-converted-space">      </span>return;</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>// Add new head</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.body.unshift(newHead);</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>// Check for food collision</p>
<p class="p1"><span class="Apple-converted-space">    </span>let ateFood = false;</p>
<p class="p1"><span class="Apple-converted-space">    </span>for (let i = 0; i &lt; foods.length; i++) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>if (newHead.x === foods[i].pos.x &amp;&amp; newHead.y === foods[i].pos.y) {</p>
<p class="p1"><span class="Apple-converted-space">        </span>foods.splice(i, 1);</p>
<p class="p1"><span class="Apple-converted-space">        </span>this.growCount += 3;</p>
<p class="p1"><span class="Apple-converted-space">        </span>scores[this.id]++;</p>
<p class="p1"><span class="Apple-converted-space">        </span>ateFood = true;</p>
<p class="p1"><span class="Apple-converted-space">        </span>break;</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>// Remove tail unless growing</p>
<p class="p1"><span class="Apple-converted-space">    </span>if (this.growCount &gt; 0) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>this.growCount--;</p>
<p class="p1"><span class="Apple-converted-space">    </span>} else {</p>
<p class="p1"><span class="Apple-converted-space">      </span>this.body.pop();</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>draw() {</p>
<p class="p1"><span class="Apple-converted-space">    </span>// Draw snake body</p>
<p class="p1"><span class="Apple-converted-space">    </span>noStroke();</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>for (let i = 0; i &lt; this.body.length; i++) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>// Create gradient effect from head to tail</p>
<p class="p1"><span class="Apple-converted-space">      </span>let segmentColor = [...this.color];</p>
<p class="p1"><span class="Apple-converted-space">      </span>let alpha = this.alive ? 255 : 120; // Dim the snake if dead</p>
<p class="p2"><span class="Apple-converted-space">      </span></p>
<p class="p1"><span class="Apple-converted-space">      </span>// Make the head brighter</p>
<p class="p1"><span class="Apple-converted-space">      </span>if (i === 0) {</p>
<p class="p1"><span class="Apple-converted-space">        </span>segmentColor = segmentColor.map(c =&gt; min(c + 50, 255));</p>
<p class="p1"><span class="Apple-converted-space">      </span>} else {</p>
<p class="p1"><span class="Apple-converted-space">        </span>// Create gradient effect</p>
<p class="p1"><span class="Apple-converted-space">        </span>let gradientFactor = 1 - (i / this.body.length) * 0.5;</p>
<p class="p1"><span class="Apple-converted-space">        </span>segmentColor = segmentColor.map(c =&gt; c * gradientFactor);</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p2"><span class="Apple-converted-space">      </span></p>
<p class="p1"><span class="Apple-converted-space">      </span>fill(segmentColor[0], segmentColor[1], segmentColor[2], alpha);</p>
<p class="p2"><span class="Apple-converted-space">      </span></p>
<p class="p1"><span class="Apple-converted-space">      </span>const x = this.body[i].x * GRID_SIZE;</p>
<p class="p1"><span class="Apple-converted-space">      </span>const y = this.body[i].y * GRID_SIZE;</p>
<p class="p2"><span class="Apple-converted-space">      </span></p>
<p class="p1"><span class="Apple-converted-space">      </span>// Draw rounded segments</p>
<p class="p1"><span class="Apple-converted-space">      </span>if (i === 0) {</p>
<p class="p1"><span class="Apple-converted-space">        </span>// Head is a circle</p>
<p class="p1"><span class="Apple-converted-space">        </span>ellipse(x + GRID_SIZE/2, y + GRID_SIZE/2, GRID_SIZE * 0.9, GRID_SIZE * 0.9);</p>
<p class="p2"><span class="Apple-converted-space">        </span></p>
<p class="p1"><span class="Apple-converted-space">        </span>// Draw eyes</p>
<p class="p1"><span class="Apple-converted-space">        </span>fill(10);</p>
<p class="p1"><span class="Apple-converted-space">        </span>let eyeOffsetX = 0;</p>
<p class="p1"><span class="Apple-converted-space">        </span>let eyeOffsetY = 0;</p>
<p class="p2"><span class="Apple-converted-space">        </span></p>
<p class="p1"><span class="Apple-converted-space">        </span>if (this.lastDirection === 'right') eyeOffsetX = 3;</p>
<p class="p1"><span class="Apple-converted-space">        </span>else if (this.lastDirection === 'left') eyeOffsetX = -3;</p>
<p class="p1"><span class="Apple-converted-space">        </span>else if (this.lastDirection === 'down') eyeOffsetY = 3;</p>
<p class="p1"><span class="Apple-converted-space">        </span>else if (this.lastDirection === 'up') eyeOffsetY = -3;</p>
<p class="p2"><span class="Apple-converted-space">        </span></p>
<p class="p1"><span class="Apple-converted-space">        </span>ellipse(x + GRID_SIZE/2 + eyeOffsetX + GRID_SIZE/5, y + GRID_SIZE/2 - GRID_SIZE/6, GRID_SIZE * 0.2, GRID_SIZE * 0.2);</p>
<p class="p1"><span class="Apple-converted-space">        </span>ellipse(x + GRID_SIZE/2 + eyeOffsetX - GRID_SIZE/5, y + GRID_SIZE/2 - GRID_SIZE/6, GRID_SIZE * 0.2, GRID_SIZE * 0.2);</p>
<p class="p1"><span class="Apple-converted-space">      </span>} else {</p>
<p class="p1"><span class="Apple-converted-space">        </span>// Body segments are rounded rects</p>
<p class="p1"><span class="Apple-converted-space">        </span>rect(x + GRID_SIZE * 0.1, y + GRID_SIZE * 0.1, GRID_SIZE * 0.8, GRID_SIZE * 0.8, GRID_SIZE * 0.3);</p>
<p class="p1"><span class="Apple-converted-space">      </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1">}</p>
<p class="p2"><br></p>
<p class="p1">class Food {</p>
<p class="p1"><span class="Apple-converted-space">  </span>constructor(pos) {</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.pos = pos;</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.color = [random(150, 255), random(150, 255), random(150, 255)];</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.pulseSize = random(0.6, 0.8);</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.pulseSpeed = random(0.05, 0.1);</p>
<p class="p1"><span class="Apple-converted-space">    </span>this.pulseOffset = random(0, TWO_PI);</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p2"><span class="Apple-converted-space">  </span></p>
<p class="p1"><span class="Apple-converted-space">  </span>draw() {</p>
<p class="p1"><span class="Apple-converted-space">    </span>// Pulsating effect</p>
<p class="p1"><span class="Apple-converted-space">    </span>let pulse = this.pulseSize + sin(frameCount * this.pulseSpeed + this.pulseOffset) * 0.1;</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>// Glow effect</p>
<p class="p1"><span class="Apple-converted-space">    </span>strokeWeight(3);</p>
<p class="p1"><span class="Apple-converted-space">    </span>stroke(this.color[0], this.color[1], this.color[2], 100);</p>
<p class="p1"><span class="Apple-converted-space">    </span>fill(this.color[0], this.color[1], this.color[2], 200);</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>// Draw food</p>
<p class="p1"><span class="Apple-converted-space">    </span>let x = this.pos.x * GRID_SIZE + GRID_SIZE/2;</p>
<p class="p1"><span class="Apple-converted-space">    </span>let y = this.pos.y * GRID_SIZE + GRID_SIZE/2;</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>// Star shape</p>
<p class="p1"><span class="Apple-converted-space">    </span>push();</p>
<p class="p1"><span class="Apple-converted-space">    </span>translate(x, y);</p>
<p class="p1"><span class="Apple-converted-space">    </span>rotate(frameCount * 0.01);</p>
<p class="p2"><span class="Apple-converted-space">    </span></p>
<p class="p1"><span class="Apple-converted-space">    </span>beginShape();</p>
<p class="p1"><span class="Apple-converted-space">    </span>for (let i = 0; i &lt; 5; i++) {</p>
<p class="p1"><span class="Apple-converted-space">      </span>let angle1 = TWO_PI / 5 * i;</p>
<p class="p1"><span class="Apple-converted-space">      </span>let x1 = cos(angle1) * GRID_SIZE/2 * pulse;</p>
<p class="p1"><span class="Apple-converted-space">      </span>let y1 = sin(angle1) * GRID_SIZE/2 * pulse;</p>
<p class="p1"><span class="Apple-converted-space">      </span>vertex(x1, y1);</p>
<p class="p2"><span class="Apple-converted-space">      </span></p>
<p class="p1"><span class="Apple-converted-space">      </span>let angle2 = TWO_PI / 5 * (i + 0.5);</p>
<p class="p1"><span class="Apple-converted-space">      </span>let x2 = cos(angle2) * GRID_SIZE/4 * pulse;</p>
<p class="p1"><span class="Apple-converted-space">      </span>let y2 = sin(angle2) * GRID_SIZE/4 * pulse;</p>
<p class="p1"><span class="Apple-converted-space">      </span>vertex(x2, y2);</p>
<p class="p1"><span class="Apple-converted-space">    </span>}</p>
<p class="p1"><span class="Apple-converted-space">    </span>endShape(CLOSE);</p>
<p class="p1"><span class="Apple-converted-space">    </span>pop();</p>
<p class="p1"><span class="Apple-converted-space">  </span>}</p>
<p class="p1">}</p>
</body>
</html>
